{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE NoImplicitPrelude #-}

module Main (main) where

import Control.Monad.Writer (Writer, execWriter, tell)
import Data.GI.CodeGen.API
import qualified Data.GI.GIR.BasicTypes as GIR
import qualified Data.GI.GIR.Documentation (rawDocText)
import Data.List (lookup)
import qualified Data.Text as T
import Relude

type Builder = Writer ([Text], [Text])

line :: Text -> Builder ()
line l = tell ([l], [])

lineJs :: Text -> Builder ()
lineJs l = tell ([], [l])

psBType :: GIR.BasicType -> Text
psBType GIR.TBoolean = "Boolean"
psBType GIR.TUTF8 = "String"
psBType GIR.TDouble = "Number"
psBType GIR.TUInt = "Int"
psBType GIR.TUInt8 = "Int"
psBType GIR.TUInt16 = "Int"
psBType GIR.TUInt32 = "Int"
psBType GIR.TUInt64 = "Int"
psBType GIR.TInt = "Int"
psBType GIR.TInt16 = "Int"
psBType GIR.TInt32 = "Int"
psBType GIR.TInt64 = "Int"
psBType GIR.TPtr = "ptr?"
psBType x = error $ "Unknown btype: " <> show x

psType :: GIR.Type -> Text
psType (GIR.TBasicType bt) = psBType bt
psType GIR.TVariant = "Variant"
psType (GIR.TCArray _ _ _ n) = maybeAddParen "Array" (psType n)
psType (GIR.TInterface n) = "(interface " <> show n <> "?)"
psType GIR.TError = "error?"
psType x = error $ "Unknown type: " <> show x

maybeAddParen :: Text -> Text -> Text
maybeAddParen base value
  | " " `T.isInfixOf` value = base <> " (" <> value <> ")"
  | otherwise = base <> " " <> value

genMethod :: Text -> Method -> Maybe (Builder ())
genMethod obj Method {..} = do
  guard isDeprecated
  renderMethod <$> methodStrM
  where
    argsStrM :: Maybe [Text]
    argsStrM = do
      let argsStr = traverse argStr (args methodCallable)
      guard (length (fromMaybe [] argsStr) == 1)
      argsStr
    isDeprecated = isNothing (callableDeprecated methodCallable)
    methodStrM :: Maybe Text
    methodStrM = do
      args <- argsStrM
      let methodStr = name methodName <> " :: " <> T.intercalate " -> " (args <> [retEff])
      guard (not $ "?" `T.isInfixOf` methodStr)
      pure methodStr
    methodJsStr =
      let (scope, arg) = case methodType of
            Constructor -> (obj, "v")
            OrdinaryMethod -> ("v", "")
            MemberFunction -> ("v", "")
       in "exports." <> name methodName <> " = v => () => " <> scope <> "." <> name methodName <> "(" <> arg <> ")"
    renderMethod methodStr = do
      line ""
      case doc of
        Just d -> line $ "-- | " <> d
        Nothing -> pure ()
      case retDoc of
        Just d -> line $ "-- Returns " <> d
        Nothing -> pure ()
      line ("foreign import " <> methodStr)
      lineJs methodJsStr
    argStr :: Arg -> Maybe Text
    argStr Arg {..} = do
      guard (direction == DirectionIn)
      pure (psType argType)
    firstLine :: Text -> Maybe Text
    firstLine = fmap head . (nonEmpty . T.lines)
    doc :: Maybe Text
    doc = firstLine =<< Data.GI.GIR.Documentation.rawDocText (callableDocumentation methodCallable)
    retDoc = T.replace "\n" "" <$> Data.GI.GIR.Documentation.rawDocText (returnDocumentation methodCallable)
    retEff = maybeAddParen "Effect" retStr
    retStr =
      if returnMayBeNull methodCallable
        then maybeAddParen "Maybe" ret
        else ret
    ret = maybe "Unit" psType (returnType methodCallable)

genBindingHeader :: Text -> Text -> Builder ()
genBindingHeader name obj = do
  lineJs "// Generated by PureGirGen.hs"
  lineJs "\"use strict\";\n"
  lineJs $ "const " <> obj <> " = imports.gi." <> name <> "." <> obj <> ";\n"

genModuleHeader :: Text -> Text -> Builder ()
genModuleHeader name obj = do
  line "-- Generated by PureGirGen.hs"
  line $ "module " <> name <> "." <> obj <> " where"
  line ""
  line "import Effect (Effect)"
  line "import Prelude (Unit)"
  line "import Data.Maybe (Maybe)"

genForeignType :: Text -> Text -> Builder ()
genForeignType "GLib" "Variant" = line "\nforeign import data Variant :: Type"
genForeignType _ _ = pure ()

genStruct :: GIRInfo -> Text -> Text -> Builder ()
genStruct gi name obj = do
  case lookup (Name name obj) (girAPIs gi) of
    Just (APIStruct s) -> do
      genBindingHeader name obj
      genModuleHeader name obj
      genForeignType name obj
      sequence_ (mapMaybe (genMethod obj) (structMethods s))
    _ -> error "Can't find"

genModule :: MonadIO m => GIRInfo -> Text -> Text -> m ()
genModule gi name obj = do
  writeSrc "purs" pureSrc
  writeSrc "js" jsSrc
  where
    (pureSrc, jsSrc) = execWriter (genStruct gi "GLib" "Variant")
    writeSrc ext xs =
      writeFile
        (T.unpack $ "../src/" <> name <> "/" <> obj <> "." <> ext)
        (T.unpack . T.unlines $ xs)

main :: IO ()
main = do
  (gi, _) <- loadGIRInfo True "GLib" Nothing [] []
  genModule gi "GLib" "Variant"
  putStrLn "Done."
